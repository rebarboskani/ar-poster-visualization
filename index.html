<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>F1 Driver Emotions AR Visualization</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }


        .ar-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
    </style>
</head>
<body>

    <div class="ar-ui">
        <h2>Point camera at the F1 poster</h2>
        <p>Scan the target image to see the 3D visualization</p>
    </div>

    <a-scene mindar-image="imageTargetSrc: targets.mind;" color-space="sRGB" renderer="colorManagement: true, physicallyCorrectLights" vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false">
        <a-assets>
            <!-- We'll create the 3D content dynamically -->
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        
        <a-entity mindar-image-target="targetIndex: 0">
            <!-- This is where our 3D visualization will be placed -->
            <a-entity id="f1-visualization" position="0 0 0.1" scale="0.5 0.5 0.5">
                <!-- 3D content will be added here via JavaScript -->
            </a-entity>
        </a-entity>
    </a-scene>

    <script>
        // Emotion data for lap 31
        const lap31Data = [
            { driver: 'ALO', frustration: 0.323544798, pressure: 0.617500849, confidence: 0.105177988, risk_taking: 0.030807275, aggressiveness: 0.001775942 },
            { driver: 'BOT', frustration: 0.727975797, pressure: 0.140316103, confidence: 0.480549578, risk_taking: 1, aggressiveness: 0.209852642 },
            { driver: 'GAS', frustration: 0.485317198, pressure: 0.630510672, confidence: 0.103525108, risk_taking: 0.030726159, aggressiveness: 0.01399344 },
            { driver: 'GIO', frustration: 0.485317198, pressure: 0.437472388, confidence: 0.227066803, risk_taking: 0.030092652, aggressiveness: 0.004172932 },
            { driver: 'HAM', frustration: 0.796142483, pressure: 0.340052056, confidence: 0.150121383, risk_taking: 0.117548898, aggressiveness: 0.003268662 },
            { driver: 'LAT', frustration: 0.485317198, pressure: 0.200273496, confidence: 0.811843627, risk_taking: 0.029494777, aggressiveness: 0.012205709 },
            { driver: 'LEC', frustration: 0.485317198, pressure: 0.412754581, confidence: 0.201731196, risk_taking: 0.030367163, aggressiveness: 0.03459888 },
            { driver: 'MSC', frustration: 0.485317198, pressure: 0.670551076, confidence: 0.135798686, risk_taking: 0.02842724, aggressiveness: 0.006858782 },
            { driver: 'NOR', frustration: 0.485317198, pressure: 0.366885779, confidence: 0.208682631, risk_taking: 0.030264732, aggressiveness: 0.019096759 },
            { driver: 'OCO', frustration: 0.485317198, pressure: 0.475136329, confidence: 0.174534518, risk_taking: 0.030998334, aggressiveness: 0.010192814 },
            { driver: 'PER', frustration: 0.485317198, pressure: 0.240449326, confidence: 0.301045268, risk_taking: 0.031178068, aggressiveness: 0.00213754 },
            { driver: 'RIC', frustration: 0.485317198, pressure: 0.391030564, confidence: 0.228950875, risk_taking: 0.030048951, aggressiveness: 0.014385012 },
            { driver: 'SAI', frustration: 0.485317198, pressure: 0.305738468, confidence: 0.251498555, risk_taking: 0.029936726, aggressiveness: 0.024871777 },
            { driver: 'STR', frustration: 0.485317198, pressure: 0.364729362, confidence: 0.301001018, risk_taking: 0.029901844, aggressiveness: 0.025246686 },
            { driver: 'TSU', frustration: 0.323544798, pressure: 0.266742267, confidence: 0.359470897, risk_taking: 0.031380498, aggressiveness: 0.028809249 },
            { driver: 'VER', frustration: 0.744710872, pressure: 0.352823666, confidence: 0.175107887, risk_taking: 0.031402166, aggressiveness: 0.009761564 },
            { driver: 'VET', frustration: 0.323544798, pressure: 0.311809755, confidence: 0.356537819, risk_taking: 0.285815829, aggressiveness: 0.55469696 }
        ];

        // Lap 31 positions from the CSV file
        const lap31Positions = [
            { position: 1, driver: 'HAM', color: '#00f5d0' },   // Mercedes
            { position: 2, driver: 'VER', color: '#0600ef' },   // Red Bull
            { position: 3, driver: 'PER', color: '#0600ef' },   // Red Bull
            { position: 4, driver: 'ALO', color: '#0755ab' },   // Alpine
            { position: 5, driver: 'GAS', color: '#2b4562' },   // AlphaTauri
            { position: 6, driver: 'SAI', color: '#dc0004' },   // Ferrari
            { position: 7, driver: 'NOR', color: '#ff8000' },   // McLaren
            { position: 8, driver: 'LEC', color: '#dc0004' },   // Ferrari
            { position: 9, driver: 'BOT', color: '#00f5d0' },   // Mercedes
            { position: 10, driver: 'TSU', color: '#2b4562' },  // AlphaTauri
            { position: 11, driver: 'OCO', color: '#0755ab' },  // Alpine
            { position: 12, driver: 'RIC', color: '#ff8000' },  // McLaren
            { position: 13, driver: 'GIO', color: '#900000' },  // Alfa Romeo
            { position: 14, driver: 'VET', color: '#00665e' },  // Aston Martin
            { position: 15, driver: 'STR', color: '#00665e' },  // Aston Martin
            { position: 16, driver: 'MSC', color: '#b6babd' },  // Haas
            { position: 17, driver: 'LAT', color: '#00a0dd' }   // Williams
        ];

        // Function to normalize emotion values
        function normalizeEmotions(data) {
            const emotions = ['frustration', 'pressure', 'confidence', 'risk_taking', 'aggressiveness'];
            const ranges = {};
            
            emotions.forEach(emotion => {
                const values = data.map(driver => driver[emotion]);
                const min = Math.min(...values);
                const max = Math.max(...values);
                ranges[emotion] = { min, max, range: max - min };
            });
            
            return data.map(driver => {
                const normalized = { driver: driver.driver };
                emotions.forEach(emotion => {
                    const value = driver[emotion];
                    const range = ranges[emotion];
                    normalized[emotion] = range.range === 0 ? 0.5 : (value - range.min) / range.range;
                });
                return normalized;
            });
        }

        // Normalize the emotion data
        const normalizedLap31Data = normalizeEmotions(lap31Data);

        // Create driver data with positions and colors
        const driverDataWithPositions = lap31Positions.map(pos => {
            const emotionData = normalizedLap31Data.find(d => d.driver === pos.driver);
            return {
                ...emotionData,
                position: pos.position,
                color: pos.color
            };
        });

        const numDrivers = driverDataWithPositions.length;
        const numRings = 20;

        // Animation parameters
        const animationParams = {
            time: 0,
            lastTime: 0,
            phases: Array.from({ length: numRings }, () => Math.random() * 2 * Math.PI),
            baseRadii: Array.from({ length: numRings }, (_, i) => 1 + i * 0.3),
            maxThickness: 0.3,
            maxOscillation: 0.3,
            maxShake: 0.1,
            maxWobble: 0.2,
            waveCount: 5,
            shakeFrequency: 10
        };

        // Create ring entities for each driver
        function createRingEntities() {
            const visualization = document.getElementById('f1-visualization');
            
            for (let i = 0; i < numDrivers; i++) {
                const driver = driverDataWithPositions[i];
                const baseRadius = animationParams.baseRadii[i];
                
                // Create ring group
                const ringGroup = document.createElement('a-entity');
                ringGroup.setAttribute('id', `ring-${i}`);
                ringGroup.setAttribute('position', '0 0 0');
                ringGroup.setAttribute('rotation', '0 0 0');
                
                // Create particles for the ring
                const numParticles = 100; // Reduced for performance
                for (let j = 0; j < numParticles; j++) {
                    const particle = document.createElement('a-sphere');
                    particle.setAttribute('radius', '0.005');
                    particle.setAttribute('color', driver.color);
                    particle.setAttribute('position', '0 0 0');
                    particle.setAttribute('opacity', '0.8');
                    
                    // Store animation data
                    particle.dataset.theta = (j / numParticles) * 2 * Math.PI;
                    particle.dataset.offset = (Math.random() - 0.5) * 2;
                    particle.dataset.jitterPhase = Math.random() * 2 * Math.PI;
                    particle.dataset.baseRadius = baseRadius;
                    particle.dataset.driverIndex = i;
                    
                    ringGroup.appendChild(particle);
                }
                
                // Create sparks
                const numSparks = 20;
                for (let j = 0; j < numSparks; j++) {
                    const spark = document.createElement('a-sphere');
                    spark.setAttribute('radius', '0.003');
                    spark.setAttribute('color', driver.color);
                    spark.setAttribute('position', '0 0 0');
                    spark.setAttribute('opacity', '0.6');
                    
                    spark.dataset.theta = Math.random() * 2 * Math.PI;
                    spark.dataset.offset = (Math.random() - 0.5) * 2;
                    spark.dataset.velocity = 0.5 + Math.random();
                    spark.dataset.life = Math.random() * 2;
                    spark.dataset.maxLife = 2;
                    spark.dataset.driverIndex = i;
                    
                    ringGroup.appendChild(spark);
                }
                
                visualization.appendChild(ringGroup);
            }
        }

        // Animation function
        function animateRings() {
            const time = Date.now() / 1000;
            const delta = time - animationParams.lastTime;
            animationParams.lastTime = time;
            animationParams.time = time;

            for (let i = 0; i < numDrivers; i++) {
                const ringGroup = document.getElementById(`ring-${i}`);
                if (!ringGroup) continue;

                const driver = driverDataWithPositions[i];
                const phase = animationParams.phases[i];

                // Apply emotion-based animations
                const orbitSpeed = driver.frustration;
                const thickness = driver.pressure;
                const oscillationAmp = driver.confidence;
                const shakeIntensity = driver.risk_taking;
                const wobbleAmp = driver.aggressiveness;

                // Orbit rotation
                const orbitFactor = orbitSpeed * (1 + i / numDrivers) * 2;
                const currentRotation = ringGroup.getAttribute('rotation');
                ringGroup.setAttribute('rotation', {
                    x: wobbleAmp * animationParams.maxWobble * Math.sin(time + phase),
                    y: currentRotation.y,
                    z: currentRotation.z + delta * orbitFactor
                });

                // Update particles
                const particles = ringGroup.querySelectorAll('a-sphere');
                particles.forEach((particle, j) => {
                    if (j < 100) { // Main particles
                        const theta = parseFloat(particle.dataset.theta);
                        const offset = parseFloat(particle.dataset.offset);
                        const jitterPhase = parseFloat(particle.dataset.jitterPhase);
                        const baseRadius = parseFloat(particle.dataset.baseRadius);

                        // Calculate position
                        let r = baseRadius + offset * thickness * animationParams.maxThickness;
                        
                        // Add shake
                        const shake = shakeIntensity * animationParams.maxShake * 
                                    Math.sin(time * animationParams.shakeFrequency + jitterPhase);
                        r *= 1 + shake;

                        // Add oscillation
                        const osc = oscillationAmp * animationParams.maxOscillation * 
                                  Math.sin(theta * animationParams.waveCount + time * 3 + phase);

                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const z = osc;

                        particle.setAttribute('position', `${x} ${y} ${z}`);
                    } else { // Sparks
                        const spark = particle;
                        spark.dataset.life = parseFloat(spark.dataset.life) + delta;
                        if (spark.dataset.life > spark.dataset.maxLife) {
                            spark.dataset.life = 0;
                        }

                        const lifeNorm = spark.dataset.life / spark.dataset.maxLife;
                        const theta = parseFloat(spark.dataset.theta);
                        const offset = parseFloat(spark.dataset.offset);
                        const velocity = parseFloat(spark.dataset.velocity);
                        const baseRadius = parseFloat(spark.dataset.baseRadius);

                        let r = baseRadius + offset * thickness * animationParams.maxThickness + 
                               lifeNorm * velocity * 1;

                        const shake = shakeIntensity * animationParams.maxShake * 
                                    Math.sin(time * animationParams.shakeFrequency + Math.random());
                        r *= 1 + shake;

                        const osc = oscillationAmp * animationParams.maxOscillation * 
                                  Math.sin(theta * animationParams.waveCount + time * 3 + phase);

                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const z = osc;

                        spark.setAttribute('position', `${x} ${y} ${z}`);
                        spark.setAttribute('opacity', 0.6 * (1 - lifeNorm));
                    }
                });
            }

            requestAnimationFrame(animateRings);
        }

        // Initialize when scene is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Scene ready
        });

        // Start animation when AR scene is ready
        document.addEventListener('renderstart', () => {
            createRingEntities();
            animateRings();
        });

        // Handle AR events
        document.addEventListener('mindar-image-target-found', () => {
            console.log('Target found!');
            document.querySelector('.ar-ui').style.display = 'none';
        });

        document.addEventListener('mindar-image-target-lost', () => {
            console.log('Target lost!');
            document.querySelector('.ar-ui').style.display = 'block';
        });


    </script>
</body>
</html>